---
layout: post
title: On the fundamentals of programming
date: 2007-12-14 11:01:02.000000000 -05:00
categories:
- coding
tags:
- music
- programming
status: publish
type: post
published: true
---
<p>Let's start with a <a href="http://www.joelonsoftware.com/articles/BestSoftwareWriting.html" title="Show, don't tell.">story</a>.</p>
<p>I am a volleyball fanatic.  I enjoy the game in a way that borders on obsession.  Lately I play three times a week for hours at a time.  Now, my position is known as middle hitter.  As you might have guessed, I'm the guy who stands in the middle of the court and tries to pound the ball through the other team's floor.</p>
<p>A few months ago, I was going through an athletic crisis.  Despite many hours of play I still wasn't that good at hitting.  In fact, I kinda sucked at it.  My other skills were decent, but when it came to spiking the heck out of the ball, something wasn't right.  I just wasn't getting the power other people were and I didn't know why.  I experimented constantly: different arm swings, changing my hand shape, snapping my wrist.  Nothing worked.  Sad and ashamed, I enrolled in a clinic hoping to cure my hitting dysfunction.</p>
<p>On the first night, the coach ordered us into a hitting drill.  No problem.  I'm focused, I'm ready; I'm going to crush this ball.  I went up for my approach and, well--tapped--the ball over the net.  Not impressive.  I tried again but with similar results.  Discreetly, the coach pulled me aside:</p>
<p>"Did you know you're taking an extra little hop before you jump?"</p>
<p>"I am?"</p>
<p>"You are.  It's taking away all your momentum so your jump is all wrong.  Get rid of that and try again."</p>
<p>On my next attempt, the set was perfect: high and tight, and I smacked it the same way you'd high-five your grandmother.  But that time, I <em>felt</em> the extra hop I was taking.  Suddenly it was so obviously there.</p>
<p>I lined up once more.  I took three strong steps, leapt in the air, and pounded down the best shot of my life.  WHAM!  I was elated.  The problem I had with hitting was simple: I was deficient in the fundamentals.  Everything I'd been tweaking was the minor stuff.  Fundamentals are the rock-solid road bed you build on.  I'd been rearranging the mile markers on a strip of sand.</p>
<p>The point here is important: mastery of any complex skill requires mastery of its fundamentals.  I think this idea just might tell us why there are so many bad programmers out there.  And I also think it tells us it's our fault.</p>
<p><strong>How does one acquire the fundamentals of programming?</strong></p>
<p>I don't think the answer lies in obtaining a computer science degree.  I once interviewed a recent <a href="http://www.mit.edu">MIT</a> graduate who'd majored in computer science.  She was articulate, had a strong GPA, and couldn't write the pseudocode to sort an array.  Really.  This is actually a familiar phenomenon.  A CS degree tells you how, theoretically, you might spike a volleyball, but that doesn't mean graduates have ever actually hit one.  Of course computer science isn't really about programming, <a href="http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/" title="Watch lecture 1a.">it's not even about computers</a>.  Now, there are lots of strong coders with CS backgrounds, but that strength is almost always acquired through their own work--they are self-taught.</p>
<p>Academia isn't much help, so we're going to have to become deadly code-ninjas on our own.  Fortunately, there is a wizened master who can point us in the right direction: <a href="http://norvig.com/">Peter Norvig</a>, whose essay "<a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a>" wins my personal Nobel for Programming Literature.  It's probably the best advice out there on the subject, and we'd all do well to follow his recommendations.  However, despite the fact that Peter is so smart his brain has its own gravitational pull, I think his essay glosses over an important point.</p>
<p>Let's look at the main thrust of Norvig's advice:</p>
<blockquote><p> Program. The best kind of learning is learning by doing. To put it more technically, "the maximal level of performance for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve." (p. 366) and "the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors."</p></blockquote>
<p>This is clearly good advice.  Surely that MIT graduate could have written me that algorithm if she'd, you know, written code before.  But check out the quotation Norvig cites.  Where exactly does one find well-defined programming tasks of an appropriate difficulty level?  How about informative feedback and corrections of errors?</p>
<p>Well?</p>
<p>It turns out that there's a shortage of things like this for programmers.  Especially new ones.  This is a serious problem, and it is this I blame for the huge numbers of coders who <a href="http://www.thedailywtf.com">lack the fundamental skills of our craft</a>.  Worse, this is our own fault: only people already skilled in an activity can devise effective training for newcomers.  Even <a href="http://www.thefreedictionary.com/worser">worser</a>: when you lack skills in the fundamentals you almost never know it.  I had <em>no idea</em> why I couldn't spike a volleyball.</p>
<p>So how do we fix this?  We do what all great thinkers do: steal a great idea from somewhere else and reuse it.  So here's my solution, shamelessly grabbed from a different, but related area of my life:</p>
<p><strong>To become a better programmer, one should practice like a musician.</strong></p>
<p>Bear with me...</p>
<p>A beautiful piano sonata is the product of thousands of perfectly executed notes.  If even one note is misplayed you have cacophony.  However, the consideration of individual notes never enters my mind while playing.  Instead, I'm thinking about making the phrases flow together, the winsome arc of the melody, or keeping the steady beat of the bass line.  It is these things that create music from mere notes.  I'm able to think of these things because my mind is free from worrying about playing individual keys, and my mind is free because of my mastery of the fundamentals.  The study of classical piano (and every other musical endeavor) devotes ample time to performing exercises.  There are perhaps <a href="http://www.amazon.com/s/ref=nb_ss_gw/104-0171174-3395900?url=search-alias%3Daps&amp;field-keywords=piano+exercises&amp;x=0&amp;y=0">hundreds of books</a> full of them.  Compared to a real piece of music they are simple and repetitive, but each exercise isolates and drills a vital skill.  This focused practice makes such skills automatic--I can play a very fast run of notes smoothly and accurately because I've quite literally practiced it thousands of times.  I no longer need to think about it.  Because of this, I am a better pianist.</p>
<p>The application of these ideas to programming should be clear.  When I'm focusing on the overall musicality of a piece, I'm operating at a <a href="http://www.paulgraham.com/power.html">higher level of abstraction</a>.  Individual details have faded away, and I'm able to focus on making something beautiful.  The same skill is required for creating beautiful programs.  If you must spend brain cycles struggling with minute implementation details you have no hope for making your solution elegant.</p>
<p>So let's take this musical idea and alter it slightly.  After all, when it comes to programming exercises, coverage is more important than repetition. Not remembering how your language retrieves values from a hash is <em>far</em> less damaging than not knowing hashes exist in the first place.</p>
<p>Fortunately, I can already point to an excellent example of these sort of problems. I believe newcomers would learn more about programming per unit time by working through <a href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">Ninety-nine Prolog Problems</a> than almost anything else.  (Replace Prolog with your language of choice).  With the ability to check your answers and also post questions on a wiki, we've even covered the "correction of errors" and "informative feedback" requirements mentioned above.  Also excellent is <a href="http://www.pythonchallenge.com/">The Python Challenge</a>, a series of riddles with programmatic solutions that get progressively harder over time.  The site is massively popular <em>and</em> makes people better programmers.  Truly, this is a phenomenal start, but there's much more to be done.</p>
<p>So how about it guys?  What are the first fifty programs someone should write to break out of that painful newcomer phase?  What topics would they <em>definitely</em> have to cover?  Later, what programs must one write to reach hacking virtuosity?  I also like to think about this a different way: what problems would you be embarrassed to tell your coworkers you can't solve?</p>
<p>I think these questions are important, and they just might help improve the overall quality of programmers out there.  If you accept programming as an art, why don't we treat it like one?  Let's start practicing like musicians, and maybe we can create something beautiful.</p>
